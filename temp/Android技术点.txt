1、抽象类和接口的区别
	java:
		相同点：
		1.抽象类和接口都不能直接实例化
		2.抽象类的子类和接口的实现类都必须实现所有的抽象方法。

		不同点：
		1.抽象类可以有非抽象的方法，并且有实现的细节，但接口不行(JDK8以后可以有)
		2.抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的；
		3.接口中不能含有构造器、静态代码块以及静态方法，而抽象类可以有构造器、静态代码块和静态方法；	
		4.一个类只能继承一个抽象类，而一个类却可以实现多个接口；
		5.抽象类访问速度比接口速度要快，因为接口需要时间去寻找在类中具体实现的方法；
		6.如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。如果你往接口中添加方法，那么你必须改变实现该接口的类。
	kotlin：

2、分别讲讲 final、static 和 synchronized 可以修饰什么，以及修饰后的作用？

	（1）final 可修饰 类、变量、方法

	修饰类，不可被继承，比如String类
	修饰变量，不可被改变，必须给定初值
	修饰方法，不可被重写

	（2）static 可修饰 类、变量、方法

	修饰内部类，不需要外部类实例，当做普通类使用
	修饰变量，通过类名直接调用
	修饰方法，通过类名直接调用

	（3）synchronized 代码块、方法，看具体代码位置，来实现代码的同步
	synchronized在java中是一个关键字，但是在kotlin中是一个内联函数
	

3、请简述一下String、StringBuffer和StringBuilder的区别？

	String 拼接字符串时每次都会创建新的对象，适合少量拼接使用，速度最慢
	StringBuffer 线程安全，适合多线程使用，比String快
	StringBuilder 线程不安全，适合单线程使用，速度最快

	String 为字符串常量，一旦创建不可以被修改，是线程安全的；String 类使用 final 修饰符，不可以被继承；String 的长度是不变的。适用于少量操作的字符串。
	StringBuffer 为字符串变量，长度是可变的，线程安全。适用于多线程下在字符缓冲区进行大量字符串操作
	StringBuilder 为字符串变量，长度是可变的，线程不安全。适用于单线程下在字符缓冲区进行大量字符串操作。
	字符串操作在执行速度：StringBuilder > StringBuffer > String
	
	
4、谈谈Error和Exception的区别？

	Exception是java程序运行中可预料的异常情况，咱们可以获取到这种异常，并且对这种异常进行业务外的处理。

	Error是java程序运行中不可预料的异常情况，这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。
	所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。

	其中的Exception又分为检查性异常和非检查性异常。两个根本的区别在于，检查性异常 必须在编写代码时，
	使用try catch捕获（比如：IOException异常）。非检查性异常 在代码编写使，可以忽略捕获操作
	（比如：ArrayIndexOutOfBoundsException），这种异常是在代码编写或者使用过程中通过规范可以避免发生的。 切记，Error是Throw不是Exception 。
	
1、“equals”与“==”、“hashCode”的区别和使用场景？
    （1）关于 ==
	== 用于比较变量所对应的内存中所存储的数值是否相同:
	变量为引用类型，== 比较的是 对象存储的内存地址
	变量为基本数据类型，== 比较的是　基本类型的数值大小
	（2）关于 equals
	默认的 	equals 与 “==” 都是比较地址，是相等的。但String重写了equals，所以String的equal比较的是内容
	
	（3）关于hashcode
	默认的，Object　类的 hashCode()方法返回这个对象存储的内存地址的 hash　值。
	重写equal时，必须重写hashcode

1、谈谈如何重写equals()方法？为什么还要重写hashCode()？	
	（1）hashcode()
		1.hashCode 的存在主要用于查找的快捷性，如 Hashtable, HashMap 等，hashCode 是用来在三列存储结构中确定对象的存储地址的。
		2.如果两个对象相同，就是适用于 euqals(java.lang.Object) 方法，那么这两个对象的 hashCode一定相同。
		3.如果对象的euqals 方法被重写，那么对象的 hashCode 也尽量重写，并且产生 hashCode 使用的对象，一定要和 equals 方法中使用的一致，否则就会违反上面提到的第二点。
		4.两个对象的 hashCode 相同，并不一定表示这两个对象就相同，也就是不一定适用于equals() 方法，只能够说明这两个对象在三列存储结构中，如 Hashtable.,他们存在同一个篮子里。
	
	（2）equals(Object obj)
		1.如果一个类没有重写 equals(Object obj)方法，则等价于通过 == 比较两个对象，即比较的是对象在内存中的空间地址是否相等。
		2.如果重写了equals(Object ibj)方法，则根据重写的方法内容去比较相等，返回 true 则相等，false 则不相等。
	
1、Java 中深拷贝与浅拷贝的区别？
	1、浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。
	2、深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。
	
	

5、什么是反射机制？反射机制的应用场景有哪些？

	概念及介绍

	JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法
	1.先得到class对象（类名、类本身、类的对象）
	2.通过class对象的对应方法得到构造器、属性、方法

	反射主要体现在动态这个词，使用灵活、性价比高。
	举例：
	1、ButterKnife注解生成的类，使用反射进行inject,一个类统筹全局。（体现性价比）
	2、Retrofit 定义一个interface就可以进行网络请求。（体现灵活）
	3、解耦
	4、逆向Hook,Xposed插件通过反射调用任意方法，为所欲为。
	Retrofit之所以简单易用,Java的动态代理功不可没而动态代理中反射又是重中之重，interface相当于配置文件，之后动态代理进行方法的加强，完成请求。
	5、fastjson，gson等

	使用：
	可以用来写一个对象的tostring方法

6、Java 中 IO 流分为几种?BIO,NIO,AIO 有什么区别?
	IO流分类：
	1、字节流， 抽象类 InputStream，OutputStream，
	2、字符流，抽象类 Reader，Writer
	
	BIO,NIO,AIO 的区别：
	BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。
	NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。
	AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。
